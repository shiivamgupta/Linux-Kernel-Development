1. Interrupts, Interrupt Handlers, Top halves versus Bottom Halves:
Interrupts: Asynchronous interrupts generated by hardware; Exception: synchronous interrupts generated by the processor.
Interrupt Request (IRQ) lines: each IRQ line is assigned a numerical value.
Interrupt handlers: also called Interrupt Service Routine (ISR), the function kernel runs in response to a specific interrupt. What differentiates interrupt handlers from other kernel functions is that: kernel invokes ISR in a special context called interrupt context, also called atomic context sometimes, because code executing in this context is unable to block.
Top halves versus bottom halves: Because the 2 goals: i) ISR executes quickly; ii) ISR performs a large amount of work - conflict with each other, so the processing of interrupts is split into two parts. The interrupt handler (ISR) is the top half, the top half runs immediately on receipt of the interrupt and performs only the work that is time-crirical. Work that can be performed later is deferred until the bottom half, the bottom half runs in the future, at a more convenient time, with all interrupts enabled.

• Registering an interrupt handler:
Drivers can register an interrupt handler and enable a given interrupt line for handling with the function request_irq(), which is declared in <linux/interrupt.h>:
	int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char* name, void* dev);
i)   1st argu: irq specifies the interrupt number to allocate. It could be hard-coded or dynamically determined.
ii)  2nd argu: handler is a function pointer to the actual interrupt handler that services this interrupt;
	typedef irqreturn_t (*irq_handler_t)(int, void*);
iii) 3rd argu: flags, defined in <linux/interrupt.h>, among all the most important ones are:
	 a) IRQF_DISABLED: if set kernel disables all interrupts (on the current processor) plus the current interrupt line disabled on all processors when executing this interrupt handler; if unset, kernel only disables the current specific interrupt line on all processors when executing that interrupt's handler.
	 b) IRQF_SAMPLE_RANDOM: This flag specifies that interrupts generated by this device should contribute to kernel entropy pool. (Kernel entropy pool provides truly random 
	 numbers derived from various random envents.) Do not set this if your device issues interrupts at a predictable rate (e.x. the system timer) or can be influenced by 
 	 external attackers (e.x. networking device)
 	 c) IRQF_TIMER: This flag specifies that this handler processes interrupts for the system timer.
	 d) IRQF_SHARED: This flag specifies that the interrupt line can be shared among multiple interrupt handlers. Each handler registered on a given line must all specify 
	 this flag; otherwise, only one handler could exist per line.
iv)  4th argu: name is the ASCII text representation of the device associated with the interrupt. These text names are used by /proc/irq and /proc/interrupts.
v)   5th argu: dev is used for shared interrupt lines. It is useful to detect the handler you wanna remove during freeing the ISR on a shared interrupt line. dev could be 
NULL if the line is not shared. This pointer is also passed into ISR on each invocation. A common practice is to pass the device driver's device structure: it is unique and might be useful in the ISR.
On success request_irq() returns 0.

Note that request_irq() can sleep, therefore cannot be called from interrupt context or other situation where code cannot block. The reason that it can sleep is that: On registration, an entry corresponding is created in /proc/irq, calls proc_mkdir() -> calls proc_create() -> calls kmalloc(), kmalloc() can sleep.

• Freeing an interrupt handler:
When the driver unloads, need to unregister the interrupt handler and potentially disable the interrupt line. Call:
	void free_irq(unsigned int irq, void* dev);
Note that the invocation of free_irq() must be made from process context.

2. Writing an interrupt handler:
• The following is a declaration of an interrupt handler:
	static irqreturn_t intr_handler(int irq, void* dev);
This declaration matches the prototype of the handler argument given to request_irq(). 
i)   1st argu: irq - the numeric value of the interrupt line the handler is servicing; 
ii)  2nd argu: dev - pointer to the same dev that was given to request_irq() when the interrupt handler is registered.
iii) return value of an interrupt handler is the special type irqreturn_t. An interrupt handler can return two special values, IRQ_NONE and IRQ_HANDLED. The former is returned when the interrupt handler detects an interrupt for which its device was not the originator. The latter is returned if the interrupt handler was correctly invoked, and its device did indeed cause the interrupt. A macro IRQ_RETVAL(val) could be used: if val is nonzero, this macor returns IRQ_HANDLED; otherwise this macro returns IRQ_NONE.
The interrupt is normally marked static because it is never called directly from another file.

• Reentrancy and interrupt handlers:
Interrupt handler in Linux need not be reentrant. When a given interrupt handler is executing, the corresponding interrupt line is masked out on all processors, preventing another interrupt on the same line from being received. Normally all other interrupts are enabled, so other interrupts are serviced, but the current line is always disabled. So the same interrupt handler is never invoked concurrently to be a nested interrupt. (But if ISR handles global resource, it still needs to be careful of deadlock!)

• Shared handlers:
i)   The IRQF_SHARED flag must be set in the flags argument to request_irq(). (All drivers sharing the interrupt line must all specify IRQF_SHARED in request_irq().)
ii)  The dev argument must be unique to each registered handler. A pointer to any per-device structure is sufficient; and you cannot pass NULL for a shared handler!
iii) The interrupt handler must be capable of distinguishing whether its device actually generated an interrupt. This requires both hardware support and associated logic in the interrupt handler. If the hardware did not offer this capability, there would be no way for the interrupt handler to know whether its associated device or some other device sharing the line caused the interrupt. 

Note that shared handlers can mix usage of IRQ_DISABLED. When the kernel receives an interrupt, it invokes sequentially each registered handler on the line.

3. Interrupt context:
In interrupt context, the current macro is not relevant (although it points to the interrupted process). Without a backing process, interrupt context cannot sleep - how could it reschedule? Therefore, if a function sleeps, you cannot use this function from an interrupt handler.
Interrupt context is time-critical because interrupt handler interrupts other code - even another interrupt handler on a different line! (Busy looping possible, but discouraged.)

• The setup of an interrupt handler's stack
i)  Historically, interrupt handlers didn't have their own stacks; instead, they share the (kernel) stack of the interrupted process. (Kernel stack is 2 pages in size. And at least one process is running at any given time, when nothing else is schedulable, the idle task runs.)
ii) From 2.6 kernel process, an option was added to reduce the stack size from 2 pages to 1 page. This reduced memory usage/pressure because every process previously needed 2 pages of contiguous, nonswappable kernel memory. To cope with this recuded stack size, interrupt handlers were given their own stack, one stack per processor, one page in size. This stack is referred to as "interrupt stack".
The interrupt handler should not care what stack setup is in use or what the size of the kernel stack is. Always use an absolute minimum amount of stack space.

4. Implementing interrupt handlers:
The path of an interrupt goes from hardware to the kernel:
A device issues an interrupt by sending electric signal over its bus to the interrupt controller --> If the interrupt line is enabled (they can be masked out), the interrupt controller sends the interrupt to the processor --> Unless the interrupt is disabled in the processor, the processor immediately stops what it is doing, disables the interrupt system, and jumps to a predefined location in memory and executes the code located there. 
This predefined point is set up by the kernel and is the entry point for interrupt handlers.

The entry point simply saves the IRQ number and stores current register values on the stack (of the interrupted process's kernel stack), then the kernel calls do_IRQ(). After the interrupted line is calculated, do_IRQ() acknowledges the receipt of the interrupt and disables interrupt delivery on the line. Next, do_IRQ() ensures a valid handler is registered on the line and it's enabled and not currently executing. If so, it calls handle_IRQ_event(), defined in kernel/irq/handler.c, to run the installed interrupt handlers for the line.

5. /proc/interrupts:
This file contains statistics related to interrupts on the system.
i)   The first column is the interrupt line. Handlers not installed on lines are not displayed.
ii)  The second column is a counter of the number of interrupts received. 
iii) The third column is the interrupt controller handling this interrupt. XT-PIC corresponds to the standard PC programmable interrupt controller. On systems with an I/O APIC, most interrupts would list IO-APIC-level or IO-APIC-edge as their interrupt controller.
iv)  The last column is the deviced associated with this interrupt, this name is supplied by the devname parameter to request_irq(). If the interrupt line is shared, all the devices registered on the line are listed.

6. Interrupt control:
• Linux kernel implements a family of interfaces for manipulating the state of interrupts: like i) enable/disable the interrupt system for the current processor; or ii) mask out an interrupt line for the entire machine. These routines are all architecture-dependent and can be found in <asm/system.h> and <asm/irq.h>
• The lock provides protection against concurrent access from another processor; whereas disabling interrupts provides protection against concurrent access from a possible interrupt handler.

• Disabling/Enabling interrupts for a local processor:
local_irq_disable()/local_irq_enable() disables/enables all interrupts locally for the current processor (and only for the current processor (no global cli and sti)).
i)  The local_irq_disable() routine is dangerous if interrupts were already disabled prior to its invocation. The corresponding call to local_irq_enable() unconditionally enables interrupts, despite the fact that they were off to begin with. 
ii) Since it becomes harder as the kernel grows in size and complexity to know all the code path leading to a function, it's much safer to save the state of the interrupt system before disabling it. Then when it is ready to reenable interrupts, simply restore to the original state. Kernel provides this mechanism:
unsigned long flags;
local_irq_save(flags); // save the current state of local interrupt delivery and then disables it.
/* ... */
local_irq_restore(flags); // restore the local interrupt delivery to the given state.
Note that the call to save and the call to restore interrupts must occur in the same function! Because at least one architecture incorporates stack information into the value (ahem, SPARC), so flags cannot be passed to another function (Specifically, it must remain on the same stack!). (So this mechanism also has its drawpoint.)

All the previous 4 functions can be called from both interrupt and process context.

• Disabling/Enabling a specific interrupt line:
In some cases it is useful to disable only a specific interrupt line for the entire system. (Masking out an interrupt line, like you might want to disable delivery of a device's interrupts before manipulating its state.)
i)   void disable_irq(unsigned int irq); disables a given interrupt line in the interrupt controller, this disables delivery of the given interrupt to all processors in the system. This function doesn't return until any currently executing handler completes, thus callers are assured not only that new interrupts will not be delivered on the given line, but also any already executing handlers have exited.
ii)  void disable_irq_nosync(unsigned int irq); does not wait for current handlers to complete.
iii) void enable_irq(unsigned int irq); enables the given interrupt line.
iv)  void synchronize_irq(unsigned int irq); waits for a specific interrupt handler to exit, if it is executing, before returning.

Note that calls to these function nest. For each call to disable_irq() or disable_irq_nosync() on a given interrupt line, only on the last call to enable_irq() is the interrupt line actually enabled. All three of these can be called from both interrupt and process context and do not sleep.
Since PCI devices have to support interrupt line sharing by specification, they should not use these interfaces (diasbling/enabling a specific interrupt line).

• Status of the interrupt system:
i)  Macro irqs_disabled(): defined in <asm/system.h> returns nonzero if the interrupt system on the local processor is disabled, otherwise it returns 0.
ii) Two macros, defined in <linux/hardirq.h>, provide an interface to check the kernel current context, they're:
	in_interrupt(): returns nonzero if the kernel is in interrupt context (including top half and bottom half.)
	in_irq(): returns nonzero only if the kernel is executing an interrupt handler.
